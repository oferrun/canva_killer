# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a scene visualization system that renders data-driven scenes using HTML/CSS. The system separates data, layout/style (template), and visual theme (colors/fonts) into distinct layers.

## Core Architecture

### Data Model

**Scene Data Items** - The content to be displayed:
- Each item has: `type` (text or image), `id`, `display_name`
- Image items include `image_url`
- Stored as JSON

**Scene Template** - Layout and style definitions:
- Defines element hierarchy and styling
- Elements can connect to data items OR graphic primitives (SVG, shapes: rectangle/circle, non-data images)
- Stored in separate file from data

**Scene Theme** - Visual styling system:
- **Color Palette**: Up to 16 colors, each with `r`, `g`, `b`, `a`, `id`, `name`
- **Font Palette**: Up to 8 fonts, each with `font_id`, `font_url`, `font_name`
- Stored in separate file from template

### Core Functionality

The main system exports a TypeScript function:
```typescript
function renderScene(scene: Scene): { html: string, css: string }
```

This function takes a complete scene (data + template + theme) and returns HTML/CSS for rendering.

## Technology Stack

- **Language**: TypeScript
- **Output**: HTML/CSS (no framework dependencies for output)

## Development Commands

```bash
# Install dependencies
npm install

# Build TypeScript to JavaScript
npm run build

# Run the wedding invitation example (generates static HTML files)
npm run example

# Generate interactive demo with live editing
npm run demo

# Validate JSON files against schemas
npm run validate

# Watch mode for development
npm run watch
```

## File Organization

**Core Implementation:**
- `types.ts` - TypeScript type definitions for Scene, Template, Theme, etc.
- `renderer.ts` - Main rendering engine with `renderScene()` function
- `example.ts` - Example usage demonstrating how to render a scene

**Sample Files:**
- `wedding-invitation-data.json` - Example scene data
- `wedding-invitation-template.json` - Example layout/template
- `wedding-invitation-theme.json` - Elegant theme (cream/rose gold)
- `wedding-invitation-theme-modern.json` - Modern theme (navy/coral)

**JSON Schemas:**
- `scene-data-schema.json` - Schema for validating scene data files
- `scene-template-schema.json` - Schema for validating template files
- `scene-theme-schema.json` - Schema for validating theme files
- `validate.ts` - Validation utility using Ajv JSON schema validator

**Output:**
- `dist/` - Compiled JavaScript (generated by TypeScript compiler)
- `wedding-invitation-elegant.html` - Static render with elegant theme
- `wedding-invitation-modern.html` - Static render with modern theme
- `interactive-demo.html` - Live editor for testing data changes and themes

## Key Implementation Details

**Element Types:**
- `data_item` - Connects to scene data (text or image from data.json)
- `shape` - Geometric primitives (rectangle, circle) styled with CSS
- `container` - Groups child elements, supports nested hierarchies
- `image` - Non-data images with direct URLs
- `svg` - Inline SVG content

**Style System:**
- Element styles reference theme colors/fonts by ID (e.g., `"color": "text_primary"`)
- Renderer resolves IDs to actual values (RGB colors, font families)
- CSS is auto-generated with proper font imports and class-based styling

**Rendering Process:**
1. Load scene data, template, and theme JSON files
2. Call `renderScene({ data, template, theme })`
3. Returns `{ html, css }` - complete markup and styles
4. Combine into full HTML document for display

**Background Elements:**
- Elements with `width: 100%` and `height: 100%` are automatically positioned absolutely with `z-index: 0`
- All other elements get `position: relative` and `z-index: 1` to stack above backgrounds
- This ensures background elements don't cover content

**JSON Schema Validation:**
- All JSON files follow strict schemas defined in `*-schema.json` files
- Run `npm run validate` to check all sample files against their schemas
- Schemas enforce structure, types, and constraints (e.g., max 16 colors, RGB 0-255)
- Use schemas for IDE autocomplete and validation in editors that support JSON Schema
